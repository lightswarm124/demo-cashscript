import { binToHex } from '@bitauth/libauth';
import AstTraversal from '../ast/AstTraversal.js';
export default class OutputSourceCodeTraversal extends AstTraversal {
    constructor() {
        super(...arguments);
        this.indentationLevel = 0;
        this.output = '';
    }
    addOutput(s, indent = false) {
        s = indent ? `${this.getIndentation()}${s}` : s;
        this.output += s;
    }
    getIndentation() {
        return '    '.repeat(this.indentationLevel);
    }
    indent() {
        this.indentationLevel += 1;
    }
    unindent() {
        this.indentationLevel -= 1;
    }
    outputSymbolTable(symbolTable) {
        if (!symbolTable)
            return;
        this.addOutput(` --> ST: ${symbolTable}`);
    }
    visitContract(node) {
        this.addOutput(`contract ${node.name}(`, true);
        node.parameters = this.visitCommaList(node.parameters);
        this.addOutput(') {');
        this.outputSymbolTable(node.symbolTable);
        this.addOutput('\n');
        this.indent();
        node.functions = this.visitList(node.functions);
        this.unindent();
        this.addOutput('}\n', true);
        return node;
    }
    visitFunctionDefinition(node) {
        this.addOutput(`function ${node.name}(`, true);
        node.parameters = this.visitCommaList(node.parameters);
        this.addOutput(')');
        this.outputSymbolTable(node.symbolTable);
        this.addOutput(' ');
        node.body = this.visit(node.body);
        this.addOutput('\n');
        return node;
    }
    visitCommaList(list) {
        return list.map((e, i) => {
            const visited = this.visit(e);
            if (i !== list.length - 1) {
                this.addOutput(', ');
            }
            return visited;
        });
    }
    visitParameter(node) {
        this.addOutput(`${node.type} ${node.name}`);
        return node;
    }
    visitVariableDefinition(node) {
        this.addOutput(`${node.type} ${node.name} = `, true);
        this.visit(node.expression);
        this.addOutput(';\n');
        return node;
    }
    visitTupleAssignment(node) {
        this.addOutput(`${node.var1.type} ${node.var1.name}, ${node.var2.type} ${node.var2.name} = `, true);
        this.visit(node.tuple);
        this.addOutput(';\n');
        return node;
    }
    visitAssign(node) {
        this.addOutput('', true);
        node.identifier = this.visit(node.identifier);
        this.addOutput(' = ');
        node.expression = this.visit(node.expression);
        this.addOutput(';\n');
        return node;
    }
    visitTimeOp(node) {
        this.addOutput(`require(${node.timeOp} >= `, true);
        node.expression = this.visit(node.expression);
        this.addOutput(');\n');
        return node;
    }
    visitRequire(node) {
        this.addOutput('require(', true);
        node.expression = this.visit(node.expression);
        this.addOutput(');\n');
        return node;
    }
    visitBranch(node) {
        this.addOutput('if (', true);
        node.condition = this.visit(node.condition);
        this.addOutput(') ');
        node.ifBlock = this.visit(node.ifBlock);
        if (node.elseBlock) {
            this.addOutput(' else ');
            node.elseBlock = this.visit(node.elseBlock);
        }
        this.addOutput('\n');
        return node;
    }
    visitBlock(node) {
        this.addOutput('{');
        this.outputSymbolTable(node.symbolTable);
        this.addOutput('\n');
        this.indent();
        node.statements = this.visitOptionalList(node.statements);
        this.unindent();
        this.addOutput('}', true);
        return node;
    }
    visitCast(node) {
        this.addOutput(`${node.type}(`);
        node.expression = this.visit(node.expression);
        this.addOutput(')');
        return node;
    }
    visitFunctionCall(node) {
        node.identifier = this.visit(node.identifier);
        this.addOutput('(');
        node.parameters = this.visitCommaList(node.parameters);
        this.addOutput(')');
        return node;
    }
    visitInstantiation(node) {
        this.addOutput('new ');
        node.identifier = this.visit(node.identifier);
        this.addOutput('(');
        node.parameters = this.visitCommaList(node.parameters);
        this.addOutput(')');
        return node;
    }
    visitTupleIndexOp(node) {
        node.tuple = this.visit(node.tuple);
        this.addOutput(`[${node.index}]`);
        return node;
    }
    visitBinaryOp(node) {
        if (node.operator.startsWith('.')) {
            node.left = this.visit(node.left);
            this.addOutput(`${node.operator}(`);
            node.right = this.visit(node.right);
            this.addOutput(')');
            return node;
        }
        this.addOutput('(');
        node.left = this.visit(node.left);
        this.addOutput(` ${node.operator} `);
        node.right = this.visit(node.right);
        this.addOutput(')');
        return node;
    }
    visitUnaryOp(node) {
        if (node.operator.startsWith('.')) {
            this.visit(node.expression);
            this.addOutput(node.operator);
            return node;
        }
        if (node.operator.includes('[i]')) {
            const [scope, op] = node.operator.split('[i]');
            this.addOutput(scope);
            this.addOutput('[');
            this.visit(node.expression);
            this.addOutput(']');
            this.addOutput(op);
            return node;
        }
        this.addOutput('(');
        this.addOutput(node.operator);
        node.expression = this.visit(node.expression);
        this.addOutput(')');
        return node;
    }
    visitNullaryOp(node) {
        this.addOutput(node.operator);
        return node;
    }
    visitArray(node) {
        this.addOutput('[');
        node.elements = this.visitCommaList(node.elements);
        this.addOutput(']');
        return node;
    }
    visitIdentifier(node) {
        this.addOutput(node.name);
        return node;
    }
    visitBoolLiteral(node) {
        this.addOutput(node.value.toString());
        return node;
    }
    visitIntLiteral(node) {
        this.addOutput(node.value.toString());
        return node;
    }
    visitStringLiteral(node) {
        this.addOutput(`${node.quote}${node.value}${node.quote}`);
        return node;
    }
    visitHexLiteral(node) {
        this.addOutput(`0x${binToHex(node.value)}`);
        return node;
    }
}
//# sourceMappingURL=OutputSourceCodeTraversal.js.map