import { PrimitiveType } from '@cashscript/utils';
import { BinaryOpNode, UnaryOpNode, TimeOpNode, AssignNode, TupleIndexOpNode, RequireNode, } from './ast/AST.js';
import { Point } from './ast/Location.js';
export class CashScriptError extends Error {
    constructor(node, message) {
        if (node.location) {
            message += ` at ${node.location.start}`;
        }
        super(message);
        this.name = this.constructor.name;
        this.node = node;
    }
}
export class ParseError extends Error {
    constructor(message, location) {
        const start = location instanceof Point ? location : location?.start;
        if (start) {
            message += ` at ${start}`;
        }
        super(message);
        this.name = this.constructor.name;
    }
}
export class UndefinedReferenceError extends CashScriptError {
    constructor(node) {
        super(node, `Undefined reference to symbol ${node.name}`);
        this.node = node;
    }
}
export class InvalidSymbolTypeError extends CashScriptError {
    constructor(node, expected) {
        super(node, `Found symbol ${node.name} with type ${node.definition?.symbolType} where type ${expected} was expected`);
        this.node = node;
        this.expected = expected;
    }
}
export class RedefinitionError extends CashScriptError {
}
export class FunctionRedefinitionError extends RedefinitionError {
    constructor(node) {
        super(node, `Redefinition of function ${node.name}`);
        this.node = node;
    }
}
export class VariableRedefinitionError extends RedefinitionError {
    constructor(node) {
        super(node, `Redefinition of variable ${node.name}`);
        this.node = node;
    }
}
export class UnusedVariableError extends CashScriptError {
    constructor(symbol) {
        super(symbol.definition, `Unused variable ${symbol.name}`);
        this.symbol = symbol;
    }
}
export class EmptyContractError extends CashScriptError {
    constructor(node) {
        super(node, `Contract ${node.name} contains no functions`);
        this.node = node;
    }
}
export class EmptyFunctionError extends CashScriptError {
    constructor(node) {
        super(node, `Function ${node.name} contains no statements`);
        this.node = node;
    }
}
export class FinalRequireStatementError extends CashScriptError {
    constructor(node) {
        super(node, 'Final statement is expected to be a require() statement');
        this.node = node;
    }
}
export class TypeError extends CashScriptError {
    constructor(node, actual, expected, message) {
        super(node, message ?? `Found type '${actual}' where type '${expected}' was expected`);
        this.actual = actual;
        this.expected = expected;
    }
}
export class InvalidParameterTypeError extends TypeError {
    constructor(node, actual, expected) {
        const name = node instanceof RequireNode ? 'require' : node.identifier.name;
        super(node, actual, expected, `Found parameters (${actual}) in call to function '${name}' where parameters (${expected}) were expected`);
    }
}
export class UnequalTypeError extends TypeError {
    constructor(node) {
        const left = node.left.type;
        const right = node.right.type;
        super(node, left, right, `Tried to apply operator '${node.operator}' to unequal types '${left}' and '${right}'`);
    }
}
export class UnsupportedTypeError extends TypeError {
    constructor(node, actual, expected) {
        if (node instanceof BinaryOpNode && node.operator.startsWith('.')) {
            if (expected === PrimitiveType.INT) {
                super(node, actual, expected, `Tried to call member 'split' with unsupported parameter type '${actual}'`);
            }
            else {
                super(node, actual, expected, `Tried to call member 'split' on unsupported type '${actual}'`);
            }
        }
        else if (node instanceof BinaryOpNode) {
            super(node, actual, expected, `Tried to apply operator '${node.operator}' to unsupported type '${actual}'`);
        }
        else if (node instanceof UnaryOpNode && node.operator.startsWith('.')) {
            super(node, actual, expected, `Tried to access member '${node.operator}' on unsupported type '${actual}'`);
        }
        else if (node instanceof UnaryOpNode && node.operator.includes('[i]')) {
            const [scope] = node.operator.split('[i]');
            super(node, actual, expected, `Tried to index '${scope}''with unsupported type '${actual}'`);
        }
        else if (node instanceof UnaryOpNode) {
            super(node, actual, expected, `Tried to apply operator '${node.operator}' to unsupported type '${actual}'`);
        }
        else if (node instanceof TimeOpNode) {
            super(node, actual, expected, `Tried to apply operator '>=' on unsupported type '${actual}'`);
        }
        else if (node instanceof TupleIndexOpNode) {
            super(node, actual, expected, `Tried to index unsupported type '${actual}'`);
        }
        else {
            super(node, actual, expected);
        }
    }
}
export class CastTypeError extends TypeError {
    constructor(node) {
        super(node, node.expression.type, node.type, `Type '${node.expression.type}' is not castable to type '${node.type}'`);
    }
}
export class CastSizeError extends CashScriptError {
    constructor(node) {
        super(node, 'Unexpected cast size argument found');
    }
}
export class AssignTypeError extends TypeError {
    constructor(node) {
        const expected = node instanceof AssignNode ? node.identifier.type : node.type;
        super(node, node.expression.type, expected, `Type '${node.expression.type}' can not be assigned to variable of type '${expected}'`);
    }
}
export class TupleAssignmentError extends CashScriptError {
    constructor(node) {
        super(node, 'Expression must return a tuple to use destructuring');
    }
}
export class ConstantConditionError extends CashScriptError {
    constructor(node, res) {
        super(node, `Condition always evaluates to ${res}`);
    }
}
export class ConstantModificationError extends CashScriptError {
    constructor(node) {
        super(node, `Tried to modify immutable variable '${node.name}'`);
    }
}
export class ArrayElementError extends CashScriptError {
    constructor(node) {
        super(node, 'Incorrect elements in array');
    }
}
export class IndexOutOfBoundsError extends CashScriptError {
    constructor(node) {
        super(node, `Index ${node.index} out of bounds`);
    }
}
export class VersionError extends Error {
    constructor(actual, constraint) {
        const message = `cashc version ${actual} does not satisfy version constraint ${constraint}`;
        super(message);
        this.name = this.constructor.name;
    }
}
//# sourceMappingURL=Errors.js.map