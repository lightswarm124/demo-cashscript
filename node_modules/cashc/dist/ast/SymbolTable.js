export class Symbol {
    constructor(name, type, symbolType, definition, parameters) {
        this.name = name;
        this.type = type;
        this.symbolType = symbolType;
        this.definition = definition;
        this.parameters = parameters;
        this.references = [];
    }
    static variable(node) {
        return new Symbol(node.name, node.type, SymbolType.VARIABLE, node);
    }
    static global(name, type) {
        return new Symbol(name, type, SymbolType.VARIABLE);
    }
    static function(name, type, parameters) {
        return new Symbol(name, type, SymbolType.FUNCTION, undefined, parameters);
    }
    static class(name, type, parameters) {
        return new Symbol(name, type, SymbolType.CLASS, undefined, parameters);
    }
    toString() {
        let str = `${this.type} ${this.name}`;
        if (this.parameters) {
            str += ` (${this.parameters})`;
        }
        return str;
    }
}
export var SymbolType;
(function (SymbolType) {
    SymbolType["VARIABLE"] = "variable";
    SymbolType["FUNCTION"] = "function";
    SymbolType["CLASS"] = "class";
})(SymbolType || (SymbolType = {}));
export class SymbolTable {
    constructor(parent) {
        this.parent = parent;
        this.symbols = new Map();
    }
    set(symbol) {
        this.symbols.set(symbol.name, symbol);
    }
    get(name) {
        return this.symbols.get(name) ?? this.parent?.get(name);
    }
    getFromThis(name) {
        return this.symbols.get(name);
    }
    toString() {
        return `[${Array.from(this.symbols).map((e) => e[1])}]`;
    }
    unusedSymbols() {
        return Array.from(this.symbols)
            .map((e) => e[1])
            .filter((s) => s.references.length === 0);
    }
}
//# sourceMappingURL=SymbolTable.js.map