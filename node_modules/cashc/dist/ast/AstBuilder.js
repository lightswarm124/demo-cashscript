import { ParseTreeVisitor } from 'antlr4';
import { hexToBin } from '@bitauth/libauth';
import { parseType } from '@cashscript/utils';
import semver from 'semver';
import { SourceFileNode, ContractNode, ParameterNode, VariableDefinitionNode, FunctionDefinitionNode, AssignNode, IdentifierNode, BranchNode, CastNode, FunctionCallNode, UnaryOpNode, BinaryOpNode, BoolLiteralNode, IntLiteralNode, HexLiteralNode, StringLiteralNode, BlockNode, TimeOpNode, ArrayNode, TupleIndexOpNode, RequireNode, InstantiationNode, TupleAssignmentNode, NullaryOpNode, } from './AST.js';
import { Location } from './Location.js';
import { NumberUnit, } from './Globals.js';
import { getPragmaName, PragmaName, getVersionOpFromCtx } from './Pragma.js';
import { version } from '../index.js';
import { ParseError, VersionError } from '../Errors.js';
export default class AstBuilder extends ParseTreeVisitor {
    constructor(tree) {
        super();
        this.tree = tree;
    }
    defaultResult() {
        return new BoolLiteralNode(false);
    }
    build() {
        return this.visit(this.tree);
    }
    visitSourceFile(ctx) {
        ctx.pragmaDirective_list().forEach((pragma) => {
            this.processPragma(pragma);
        });
        const contract = this.visit(ctx.contractDefinition());
        const sourceFileNode = new SourceFileNode(contract);
        sourceFileNode.location = Location.fromCtx(ctx);
        return sourceFileNode;
    }
    processPragma(ctx) {
        const pragmaName = getPragmaName(ctx.pragmaName().getText());
        if (pragmaName !== PragmaName.CASHSCRIPT)
            throw new Error(); // Shouldn't happen
        // Strip any -beta tags
        const actualVersion = version.replace(/-.*/g, '');
        ctx.pragmaValue().versionConstraint_list().forEach((constraint) => {
            const op = getVersionOpFromCtx(constraint.versionOperator());
            const versionConstraint = `${op}${constraint.VersionLiteral().getText()}`;
            if (!semver.satisfies(actualVersion, versionConstraint)) {
                throw new VersionError(actualVersion, versionConstraint);
            }
        });
    }
    visitContractDefinition(ctx) {
        const name = ctx.Identifier().getText();
        const parameters = ctx.parameterList().parameter_list().map((p) => this.visit(p));
        const functions = ctx.functionDefinition_list().map((f) => this.visit(f));
        const contract = new ContractNode(name, parameters, functions);
        contract.location = Location.fromCtx(ctx);
        return contract;
    }
    visitFunctionDefinition(ctx) {
        const name = ctx.Identifier().getText();
        const parameters = ctx.parameterList().parameter_list().map((p) => this.visit(p));
        const statements = ctx.statement_list().map((s) => this.visit(s));
        const block = new BlockNode(statements);
        block.location = Location.fromCtx(ctx);
        const functionDefinition = new FunctionDefinitionNode(name, parameters, block);
        functionDefinition.location = Location.fromCtx(ctx);
        return functionDefinition;
    }
    visitParameter(ctx) {
        const type = parseType(ctx.typeName().getText());
        const name = ctx.Identifier().getText();
        const parameter = new ParameterNode(type, name);
        parameter.location = Location.fromCtx(ctx);
        return parameter;
    }
    visitStatement(ctx) {
        // Statement nodes only have a single child, so we can just visit that child
        return this.visit(ctx.getChild(0));
    }
    visitVariableDefinition(ctx) {
        const type = parseType(ctx.typeName().getText());
        const modifiers = ctx.modifier_list().map((modifier) => modifier.getText());
        const name = ctx.Identifier().getText();
        const expression = this.visit(ctx.expression());
        const variableDefinition = new VariableDefinitionNode(type, modifiers, name, expression);
        variableDefinition.location = Location.fromCtx(ctx);
        return variableDefinition;
    }
    visitTupleAssignment(ctx) {
        const expression = this.visit(ctx.expression());
        const names = ctx.Identifier_list();
        const types = ctx.typeName_list();
        const [var1, var2] = names.map((name, i) => ({
            name: name.getText(),
            type: parseType(types[i].getText()),
        }));
        const tupleAssignment = new TupleAssignmentNode(var1, var2, expression);
        tupleAssignment.location = Location.fromCtx(ctx);
        return tupleAssignment;
    }
    visitAssignStatement(ctx) {
        const identifier = new IdentifierNode(ctx.Identifier().getText());
        identifier.location = Location.fromToken(ctx.Identifier().symbol);
        const expression = this.visit(ctx.expression());
        const assign = new AssignNode(identifier, expression);
        assign.location = Location.fromCtx(ctx);
        return assign;
    }
    visitTimeOpStatement(ctx) {
        const expression = this.visit(ctx.expression());
        const timeOp = new TimeOpNode(ctx.TxVar().getText(), expression);
        timeOp.location = Location.fromCtx(ctx);
        return timeOp;
    }
    visitRequireStatement(ctx) {
        const expression = this.visit(ctx.expression());
        const require = new RequireNode(expression);
        require.location = Location.fromCtx(ctx);
        return require;
    }
    visitIfStatement(ctx) {
        const condition = this.visit(ctx.expression());
        const ifBlock = this.visit(ctx._ifBlock);
        const elseBlock = ctx._elseBlock && this.visit(ctx._elseBlock);
        const branch = new BranchNode(condition, ifBlock, elseBlock);
        branch.location = Location.fromCtx(ctx);
        return branch;
    }
    visitBlock(ctx) {
        const statements = ctx.statement_list().map((s) => this.visit(s));
        const block = new BlockNode(statements);
        block.location = Location.fromCtx(ctx);
        return block;
    }
    visitParenthesised(ctx) {
        return this.visit(ctx.expression());
    }
    visitCast(ctx) {
        const type = parseType(ctx.typeName().getText());
        const expression = this.visit(ctx._castable);
        const size = ctx._size && this.visit(ctx._size);
        const cast = new CastNode(type, expression, size);
        cast.location = Location.fromCtx(ctx);
        return cast;
    }
    visitFunctionCallExpression(ctx) {
        return this.visit(ctx.functionCall());
    }
    visitFunctionCall(ctx) {
        const identifier = new IdentifierNode(ctx.Identifier().getText());
        identifier.location = Location.fromToken(ctx.Identifier().symbol);
        const parameters = ctx.expressionList().expression_list().map((e) => this.visit(e));
        const functionCall = new FunctionCallNode(identifier, parameters);
        functionCall.location = Location.fromCtx(ctx);
        return functionCall;
    }
    visitInstantiation(ctx) {
        const identifier = new IdentifierNode(ctx.Identifier().getText());
        identifier.location = Location.fromToken(ctx.Identifier().symbol);
        const parameters = ctx.expressionList().expression_list().map((e) => this.visit(e));
        const instantiation = new InstantiationNode(identifier, parameters);
        instantiation.location = Location.fromCtx(ctx);
        return instantiation;
    }
    visitTupleIndexOp(ctx) {
        const tuple = this.visit(ctx.expression());
        const index = parseInt(ctx._index.text, 10);
        const tupleIndexOp = new TupleIndexOpNode(tuple, index);
        tupleIndexOp.location = Location.fromCtx(ctx);
        return tupleIndexOp;
    }
    visitNullaryOp(ctx) {
        const operator = ctx.getText();
        const nullaryOp = new NullaryOpNode(operator);
        nullaryOp.location = Location.fromCtx(ctx);
        return nullaryOp;
    }
    visitUnaryIntrospectionOp(ctx) {
        const operator = `${ctx._scope.text}[i]${ctx._op.text}`;
        const expression = this.visit(ctx.expression());
        const unaryOp = new UnaryOpNode(operator, expression);
        unaryOp.location = Location.fromCtx(ctx);
        return unaryOp;
    }
    visitUnaryOp(ctx) {
        const operator = ctx._op.text;
        const expression = this.visit(ctx.expression());
        const unaryOp = new UnaryOpNode(operator, expression);
        unaryOp.location = Location.fromCtx(ctx);
        return unaryOp;
    }
    visitBinaryOp(ctx) {
        const left = this.visit(ctx._left);
        const operator = ctx._op.text;
        const right = this.visit(ctx._right);
        const binaryOp = new BinaryOpNode(left, operator, right);
        binaryOp.location = Location.fromCtx(ctx);
        return binaryOp;
    }
    visitArray(ctx) {
        const elements = ctx.expression_list().map((e) => this.visit(e));
        const array = new ArrayNode(elements);
        array.location = Location.fromCtx(ctx);
        return array;
    }
    visitIdentifier(ctx) {
        const identifier = new IdentifierNode(ctx.Identifier().getText());
        identifier.location = Location.fromCtx(ctx);
        return identifier;
    }
    visitLiteralExpression(ctx) {
        return this.createLiteral(ctx.literal());
    }
    createLiteral(ctx) {
        if (ctx.BooleanLiteral()) {
            return this.createBooleanLiteral(ctx);
        }
        if (ctx.numberLiteral()) {
            return this.createIntLiteral(ctx);
        }
        if (ctx.StringLiteral()) {
            return this.createStringLiteral(ctx);
        }
        if (ctx.DateLiteral()) {
            return this.createDateLiteral(ctx);
        }
        if (ctx.HexLiteral()) {
            return this.createHexLiteral(ctx);
        }
        throw new Error(); // Should not happen
    }
    createBooleanLiteral(ctx) {
        const boolString = ctx.BooleanLiteral().getText();
        const boolValue = boolString === 'true';
        const booleanLiteral = new BoolLiteralNode(boolValue);
        booleanLiteral.location = Location.fromCtx(ctx);
        return booleanLiteral;
    }
    createIntLiteral(ctx) {
        const numberCtx = ctx.numberLiteral();
        const numberString = numberCtx.NumberLiteral().getText();
        const numberUnit = numberCtx.NumberUnit()?.getText();
        const numberValue = BigInt(numberString) * BigInt(numberUnit ? NumberUnit[numberUnit.toUpperCase()] : 1);
        const intLiteral = new IntLiteralNode(numberValue);
        intLiteral.location = Location.fromCtx(ctx);
        return intLiteral;
    }
    createStringLiteral(ctx) {
        const rawString = ctx.StringLiteral().getText();
        const stringValue = rawString.substring(1, rawString.length - 1);
        const quote = rawString.substring(0, 1);
        const stringLiteral = new StringLiteralNode(stringValue, quote);
        stringLiteral.location = Location.fromCtx(ctx);
        return stringLiteral;
    }
    createDateLiteral(ctx) {
        const rawString = ctx.DateLiteral().getText();
        const stringValue = rawString.substring(6, rawString.length - 2).trim();
        if (!/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d$/.test(stringValue)) {
            throw new ParseError('Date should be in format `YYYY-MM-DDThh:mm:ss`', Location.fromCtx(ctx));
        }
        const timestamp = Math.round(Date.parse(stringValue) / 1000);
        if (Number.isNaN(timestamp)) {
            throw new ParseError(`Incorrectly formatted date "${stringValue}"`, Location.fromCtx(ctx));
        }
        const intLiteral = new IntLiteralNode(BigInt(timestamp));
        intLiteral.location = Location.fromCtx(ctx);
        return intLiteral;
    }
    createHexLiteral(ctx) {
        const hexString = ctx.HexLiteral().getText();
        const hexValue = hexToBin(hexString.substring(2));
        const hexLiteral = new HexLiteralNode(hexValue);
        hexLiteral.location = Location.fromCtx(ctx);
        return hexLiteral;
    }
    // For safety reasons, we throw an error when the "default" visitChildren is called. *All* nodes
    // must have a custom visit method, so that we can be sure that we've covered all cases.
    visitChildren() {
        throw new Error('Safety Warning: Unhandled node in AST builder');
    }
}
//# sourceMappingURL=AstBuilder.js.map