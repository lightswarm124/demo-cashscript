import { ParseTree, ParseTreeVisitor } from 'antlr4';
import { Node, SourceFileNode, ContractNode, ParameterNode, VariableDefinitionNode, FunctionDefinitionNode, AssignNode, IdentifierNode, BranchNode, CastNode, FunctionCallNode, UnaryOpNode, BinaryOpNode, BoolLiteralNode, IntLiteralNode, HexLiteralNode, StringLiteralNode, ExpressionNode, StatementNode, LiteralNode, BlockNode, TimeOpNode, ArrayNode, TupleIndexOpNode, RequireNode, InstantiationNode, TupleAssignmentNode, NullaryOpNode } from './AST.js';
import type { ContractDefinitionContext, FunctionDefinitionContext, VariableDefinitionContext, TupleAssignmentContext, ParameterContext, AssignStatementContext, IfStatementContext, FunctionCallContext, CastContext, LiteralContext, SourceFileContext, BlockContext, TimeOpStatementContext, ArrayContext, ParenthesisedContext, FunctionCallExpressionContext, UnaryOpContext, BinaryOpContext, IdentifierContext, LiteralExpressionContext, TupleIndexOpContext, RequireStatementContext, PragmaDirectiveContext, InstantiationContext, NullaryOpContext, UnaryIntrospectionOpContext, StatementContext } from '../grammar/CashScriptParser.js';
import CashScriptVisitor from '../grammar/CashScriptVisitor.js';
export default class AstBuilder extends ParseTreeVisitor<Node> implements CashScriptVisitor<Node> {
    private tree;
    constructor(tree: ParseTree);
    defaultResult(): Node;
    build(): Node;
    visitSourceFile(ctx: SourceFileContext): SourceFileNode;
    processPragma(ctx: PragmaDirectiveContext): void;
    visitContractDefinition(ctx: ContractDefinitionContext): ContractNode;
    visitFunctionDefinition(ctx: FunctionDefinitionContext): FunctionDefinitionNode;
    visitParameter(ctx: ParameterContext): ParameterNode;
    visitStatement(ctx: StatementContext): StatementNode;
    visitVariableDefinition(ctx: VariableDefinitionContext): VariableDefinitionNode;
    visitTupleAssignment(ctx: TupleAssignmentContext): TupleAssignmentNode;
    visitAssignStatement(ctx: AssignStatementContext): AssignNode;
    visitTimeOpStatement(ctx: TimeOpStatementContext): TimeOpNode;
    visitRequireStatement(ctx: RequireStatementContext): RequireNode;
    visitIfStatement(ctx: IfStatementContext): BranchNode;
    visitBlock(ctx: BlockContext): BlockNode;
    visitParenthesised(ctx: ParenthesisedContext): ExpressionNode;
    visitCast(ctx: CastContext): CastNode;
    visitFunctionCallExpression(ctx: FunctionCallExpressionContext): FunctionCallNode;
    visitFunctionCall(ctx: FunctionCallContext): FunctionCallNode;
    visitInstantiation(ctx: InstantiationContext): InstantiationNode;
    visitTupleIndexOp(ctx: TupleIndexOpContext): TupleIndexOpNode;
    visitNullaryOp(ctx: NullaryOpContext): NullaryOpNode;
    visitUnaryIntrospectionOp(ctx: UnaryIntrospectionOpContext): UnaryOpNode;
    visitUnaryOp(ctx: UnaryOpContext): UnaryOpNode;
    visitBinaryOp(ctx: BinaryOpContext): BinaryOpNode;
    visitArray(ctx: ArrayContext): ArrayNode;
    visitIdentifier(ctx: IdentifierContext): IdentifierNode;
    visitLiteralExpression(ctx: LiteralExpressionContext): LiteralNode;
    createLiteral(ctx: LiteralContext): LiteralNode;
    createBooleanLiteral(ctx: LiteralContext): BoolLiteralNode;
    createIntLiteral(ctx: LiteralContext): IntLiteralNode;
    createStringLiteral(ctx: LiteralContext): StringLiteralNode;
    createDateLiteral(ctx: LiteralContext): IntLiteralNode;
    createHexLiteral(ctx: LiteralContext): HexLiteralNode;
    visitChildren(): Node;
}
