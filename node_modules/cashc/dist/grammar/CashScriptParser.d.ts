import { ATN, DFA, FailedPredicateException, Parser, RuleContext, ParserRuleContext, TerminalNode, Token, TokenStream } from 'antlr4';
import CashScriptVisitor from "./CashScriptVisitor.js";
export default class CashScriptParser extends Parser {
    static readonly T__0 = 1;
    static readonly T__1 = 2;
    static readonly T__2 = 3;
    static readonly T__3 = 4;
    static readonly T__4 = 5;
    static readonly T__5 = 6;
    static readonly T__6 = 7;
    static readonly T__7 = 8;
    static readonly T__8 = 9;
    static readonly T__9 = 10;
    static readonly T__10 = 11;
    static readonly T__11 = 12;
    static readonly T__12 = 13;
    static readonly T__13 = 14;
    static readonly T__14 = 15;
    static readonly T__15 = 16;
    static readonly T__16 = 17;
    static readonly T__17 = 18;
    static readonly T__18 = 19;
    static readonly T__19 = 20;
    static readonly T__20 = 21;
    static readonly T__21 = 22;
    static readonly T__22 = 23;
    static readonly T__23 = 24;
    static readonly T__24 = 25;
    static readonly T__25 = 26;
    static readonly T__26 = 27;
    static readonly T__27 = 28;
    static readonly T__28 = 29;
    static readonly T__29 = 30;
    static readonly T__30 = 31;
    static readonly T__31 = 32;
    static readonly T__32 = 33;
    static readonly T__33 = 34;
    static readonly T__34 = 35;
    static readonly T__35 = 36;
    static readonly T__36 = 37;
    static readonly T__37 = 38;
    static readonly T__38 = 39;
    static readonly T__39 = 40;
    static readonly T__40 = 41;
    static readonly T__41 = 42;
    static readonly T__42 = 43;
    static readonly T__43 = 44;
    static readonly T__44 = 45;
    static readonly T__45 = 46;
    static readonly T__46 = 47;
    static readonly T__47 = 48;
    static readonly T__48 = 49;
    static readonly T__49 = 50;
    static readonly T__50 = 51;
    static readonly T__51 = 52;
    static readonly T__52 = 53;
    static readonly T__53 = 54;
    static readonly T__54 = 55;
    static readonly T__55 = 56;
    static readonly VersionLiteral = 57;
    static readonly BooleanLiteral = 58;
    static readonly NumberUnit = 59;
    static readonly NumberLiteral = 60;
    static readonly Bytes = 61;
    static readonly Bound = 62;
    static readonly StringLiteral = 63;
    static readonly DateLiteral = 64;
    static readonly HexLiteral = 65;
    static readonly TxVar = 66;
    static readonly NullaryOp = 67;
    static readonly Identifier = 68;
    static readonly WHITESPACE = 69;
    static readonly COMMENT = 70;
    static readonly LINE_COMMENT = 71;
    static readonly EOF: number;
    static readonly RULE_sourceFile = 0;
    static readonly RULE_pragmaDirective = 1;
    static readonly RULE_pragmaName = 2;
    static readonly RULE_pragmaValue = 3;
    static readonly RULE_versionConstraint = 4;
    static readonly RULE_versionOperator = 5;
    static readonly RULE_contractDefinition = 6;
    static readonly RULE_functionDefinition = 7;
    static readonly RULE_parameterList = 8;
    static readonly RULE_parameter = 9;
    static readonly RULE_block = 10;
    static readonly RULE_statement = 11;
    static readonly RULE_variableDefinition = 12;
    static readonly RULE_tupleAssignment = 13;
    static readonly RULE_assignStatement = 14;
    static readonly RULE_timeOpStatement = 15;
    static readonly RULE_requireStatement = 16;
    static readonly RULE_ifStatement = 17;
    static readonly RULE_functionCall = 18;
    static readonly RULE_expressionList = 19;
    static readonly RULE_expression = 20;
    static readonly RULE_modifier = 21;
    static readonly RULE_literal = 22;
    static readonly RULE_numberLiteral = 23;
    static readonly RULE_typeName = 24;
    static readonly literalNames: (string | null)[];
    static readonly symbolicNames: (string | null)[];
    static readonly ruleNames: string[];
    get grammarFileName(): string;
    get literalNames(): (string | null)[];
    get symbolicNames(): (string | null)[];
    get ruleNames(): string[];
    get serializedATN(): number[];
    protected createFailedPredicateException(predicate?: string, message?: string): FailedPredicateException;
    constructor(input: TokenStream);
    sourceFile(): SourceFileContext;
    pragmaDirective(): PragmaDirectiveContext;
    pragmaName(): PragmaNameContext;
    pragmaValue(): PragmaValueContext;
    versionConstraint(): VersionConstraintContext;
    versionOperator(): VersionOperatorContext;
    contractDefinition(): ContractDefinitionContext;
    functionDefinition(): FunctionDefinitionContext;
    parameterList(): ParameterListContext;
    parameter(): ParameterContext;
    block(): BlockContext;
    statement(): StatementContext;
    variableDefinition(): VariableDefinitionContext;
    tupleAssignment(): TupleAssignmentContext;
    assignStatement(): AssignStatementContext;
    timeOpStatement(): TimeOpStatementContext;
    requireStatement(): RequireStatementContext;
    ifStatement(): IfStatementContext;
    functionCall(): FunctionCallContext;
    expressionList(): ExpressionListContext;
    expression(): ExpressionContext;
    expression(_p: number): ExpressionContext;
    modifier(): ModifierContext;
    literal(): LiteralContext;
    numberLiteral(): NumberLiteralContext;
    typeName(): TypeNameContext;
    sempred(localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    private expression_sempred;
    static readonly _serializedATN: number[];
    private static __ATN;
    static get _ATN(): ATN;
    static DecisionsToDFA: DFA[];
}
export declare class SourceFileContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    contractDefinition(): ContractDefinitionContext;
    EOF(): TerminalNode;
    pragmaDirective_list(): PragmaDirectiveContext[];
    pragmaDirective(i: number): PragmaDirectiveContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class PragmaDirectiveContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    pragmaName(): PragmaNameContext;
    pragmaValue(): PragmaValueContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class PragmaNameContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class PragmaValueContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    versionConstraint_list(): VersionConstraintContext[];
    versionConstraint(i: number): VersionConstraintContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class VersionConstraintContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    VersionLiteral(): TerminalNode;
    versionOperator(): VersionOperatorContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class VersionOperatorContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ContractDefinitionContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    Identifier(): TerminalNode;
    parameterList(): ParameterListContext;
    functionDefinition_list(): FunctionDefinitionContext[];
    functionDefinition(i: number): FunctionDefinitionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class FunctionDefinitionContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    Identifier(): TerminalNode;
    parameterList(): ParameterListContext;
    statement_list(): StatementContext[];
    statement(i: number): StatementContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ParameterListContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    parameter_list(): ParameterContext[];
    parameter(i: number): ParameterContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ParameterContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    typeName(): TypeNameContext;
    Identifier(): TerminalNode;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class BlockContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    statement_list(): StatementContext[];
    statement(i: number): StatementContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class StatementContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    variableDefinition(): VariableDefinitionContext;
    tupleAssignment(): TupleAssignmentContext;
    assignStatement(): AssignStatementContext;
    timeOpStatement(): TimeOpStatementContext;
    requireStatement(): RequireStatementContext;
    ifStatement(): IfStatementContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class VariableDefinitionContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    typeName(): TypeNameContext;
    Identifier(): TerminalNode;
    expression(): ExpressionContext;
    modifier_list(): ModifierContext[];
    modifier(i: number): ModifierContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class TupleAssignmentContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    typeName_list(): TypeNameContext[];
    typeName(i: number): TypeNameContext;
    Identifier_list(): TerminalNode[];
    Identifier(i: number): TerminalNode;
    expression(): ExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class AssignStatementContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    Identifier(): TerminalNode;
    expression(): ExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class TimeOpStatementContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    TxVar(): TerminalNode;
    expression(): ExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class RequireStatementContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    expression(): ExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class IfStatementContext extends ParserRuleContext {
    _ifBlock: BlockContext;
    _elseBlock: BlockContext;
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    expression(): ExpressionContext;
    block_list(): BlockContext[];
    block(i: number): BlockContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class FunctionCallContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    Identifier(): TerminalNode;
    expressionList(): ExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ExpressionListContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    expression_list(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ExpressionContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    get ruleIndex(): number;
    copyFrom(ctx: ExpressionContext): void;
}
export declare class CastContext extends ExpressionContext {
    _castable: ExpressionContext;
    _size: ExpressionContext;
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    typeName(): TypeNameContext;
    expression_list(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class UnaryIntrospectionOpContext extends ExpressionContext {
    _scope: Token;
    _op: Token;
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    expression(): ExpressionContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ArrayContext extends ExpressionContext {
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    expression_list(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class UnaryOpContext extends ExpressionContext {
    _op: Token;
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    expression(): ExpressionContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class IdentifierContext extends ExpressionContext {
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    Identifier(): TerminalNode;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class LiteralExpressionContext extends ExpressionContext {
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    literal(): LiteralContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class TupleIndexOpContext extends ExpressionContext {
    _index: Token;
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    expression(): ExpressionContext;
    NumberLiteral(): TerminalNode;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class InstantiationContext extends ExpressionContext {
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    Identifier(): TerminalNode;
    expressionList(): ExpressionListContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class FunctionCallExpressionContext extends ExpressionContext {
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    functionCall(): FunctionCallContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class NullaryOpContext extends ExpressionContext {
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    NullaryOp(): TerminalNode;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ParenthesisedContext extends ExpressionContext {
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    expression(): ExpressionContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class BinaryOpContext extends ExpressionContext {
    _left: ExpressionContext;
    _op: Token;
    _right: ExpressionContext;
    constructor(parser: CashScriptParser, ctx: ExpressionContext);
    expression_list(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class ModifierContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class LiteralContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    BooleanLiteral(): TerminalNode;
    numberLiteral(): NumberLiteralContext;
    StringLiteral(): TerminalNode;
    DateLiteral(): TerminalNode;
    HexLiteral(): TerminalNode;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class NumberLiteralContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    NumberLiteral(): TerminalNode;
    NumberUnit(): TerminalNode;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
export declare class TypeNameContext extends ParserRuleContext {
    constructor(parser?: CashScriptParser, parent?: ParserRuleContext, invokingState?: number);
    Bytes(): TerminalNode;
    get ruleIndex(): number;
    accept<Result>(visitor: CashScriptVisitor<Result>): Result;
}
