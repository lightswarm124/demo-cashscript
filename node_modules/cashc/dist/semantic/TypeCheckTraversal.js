import { PrimitiveType, explicitlyCastable, implicitlyCastable, implicitlyCastableSignature, resultingType, arrayType, ArrayType, TupleType, BytesType, } from '@cashscript/utils';
import { BinaryOpNode, VariableDefinitionNode, } from '../ast/AST.js';
import AstTraversal from '../ast/AstTraversal.js';
import { InvalidParameterTypeError, UnequalTypeError, UnsupportedTypeError, CastTypeError, TypeError, AssignTypeError, ArrayElementError, IndexOutOfBoundsError, CastSizeError, TupleAssignmentError, } from '../Errors.js';
import { BinaryOperator, NullaryOperator, UnaryOperator } from '../ast/Operator.js';
import { GlobalFunction } from '../ast/Globals.js';
export default class TypeCheckTraversal extends AstTraversal {
    visitVariableDefinition(node) {
        node.expression = this.visit(node.expression);
        expectAssignable(node, node.expression.type, node.type);
        return node;
    }
    visitTupleAssignment(node) {
        node.tuple = this.visit(node.tuple);
        if (!(node.tuple instanceof BinaryOpNode) || node.tuple.operator !== BinaryOperator.SPLIT) {
            throw new TupleAssignmentError(node.tuple);
        }
        const tupleType = node.tuple.left.type;
        for (const variable of [node.var1, node.var2]) {
            if (!implicitlyCastable(tupleType, variable.type)) {
                // Ignore if both are of type byte. problem: bytes16 can be typed to bytes32
                if (tupleType instanceof BytesType && variable.type instanceof BytesType) {
                    return node;
                }
                throw new AssignTypeError(new VariableDefinitionNode(variable.type, [], variable.name, node.tuple));
            }
        }
        return node;
    }
    visitAssign(node) {
        node.identifier = this.visit(node.identifier);
        node.expression = this.visit(node.expression);
        expectAssignable(node, node.expression.type, node.identifier.type);
        return node;
    }
    visitTimeOp(node) {
        node.expression = this.visit(node.expression);
        expectInt(node, node.expression.type);
        return node;
    }
    visitRequire(node) {
        node.expression = this.visit(node.expression);
        const parameters = node.expression.type ? [node.expression.type] : [];
        expectParameters(node, parameters, [PrimitiveType.BOOL]);
        return node;
    }
    visitBranch(node) {
        node.condition = this.visit(node.condition);
        node.ifBlock = this.visit(node.ifBlock);
        node.elseBlock = this.visitOptional(node.elseBlock);
        if (!implicitlyCastable(node.condition.type, PrimitiveType.BOOL)) {
            throw new TypeError(node, node.condition.type, PrimitiveType.BOOL);
        }
        return node;
    }
    visitCast(node) {
        node.expression = this.visit(node.expression);
        node.size = this.visitOptional(node.size);
        if (!explicitlyCastable(node.expression.type, node.type)) {
            throw new CastTypeError(node);
        }
        // Variable size cast is only possible from INT to unbounded BYTES
        if (node.size) {
            if (node.expression.type !== PrimitiveType.INT || node.type.toString() !== 'bytes') {
                throw new CastSizeError(node);
            }
        }
        return node;
    }
    visitFunctionCall(node) {
        node.identifier = this.visit(node.identifier);
        node.parameters = this.visitList(node.parameters);
        const { definition, type } = node.identifier;
        if (!definition || !definition.parameters)
            return node; // already checked in symbol table
        const parameterTypes = node.parameters.map((p) => p.type);
        expectParameters(node, parameterTypes, definition.parameters);
        // Additional array length check for checkMultiSig
        if (node.identifier.name === GlobalFunction.CHECKMULTISIG) {
            const sigs = node.parameters[0];
            const pks = node.parameters[1];
            if (sigs.elements.length > pks.elements.length) {
                throw new ArrayElementError(pks);
            }
        }
        node.type = type;
        return node;
    }
    visitInstantiation(node) {
        node.identifier = this.visit(node.identifier);
        node.parameters = this.visitList(node.parameters);
        const { definition, type } = node.identifier;
        if (!definition || !definition.parameters)
            return node; // already checked in symbol table
        const parameterTypes = node.parameters.map((p) => p.type);
        expectParameters(node, parameterTypes, definition.parameters);
        node.type = type;
        return node;
    }
    visitTupleIndexOp(node) {
        node.tuple = this.visit(node.tuple);
        expectTuple(node, node.tuple.type);
        if (node.index !== 0 && node.index !== 1) {
            throw new IndexOutOfBoundsError(node);
        }
        node.type = node.tuple.type.elementType;
        return node;
    }
    visitBinaryOp(node) {
        node.left = this.visit(node.left);
        node.right = this.visit(node.right);
        const resType = resultingType(node.left.type, node.right.type);
        if (!resType && !node.operator.startsWith('.')) {
            throw new UnequalTypeError(node);
        }
        switch (node.operator) {
            case BinaryOperator.PLUS:
                expectAnyOfTypes(node, resType, [PrimitiveType.INT, PrimitiveType.STRING, new BytesType()]);
                node.type = resType;
                // Infer new bounded bytes type if both operands are bounded bytes types
                if (node.left.type instanceof BytesType && node.right.type instanceof BytesType) {
                    if (node.left.type.bound && node.right.type.bound) {
                        node.type = new BytesType(node.left.type.bound + node.right.type.bound);
                    }
                }
                return node;
            case BinaryOperator.MUL:
            case BinaryOperator.DIV:
            case BinaryOperator.MOD:
            case BinaryOperator.MINUS:
                expectInt(node, resType);
                node.type = resType;
                return node;
            case BinaryOperator.LT:
            case BinaryOperator.LE:
            case BinaryOperator.GT:
            case BinaryOperator.GE:
                expectInt(node, resType);
                node.type = PrimitiveType.BOOL;
                return node;
            case BinaryOperator.EQ:
            case BinaryOperator.NE:
                node.type = PrimitiveType.BOOL;
                return node;
            case BinaryOperator.AND:
            case BinaryOperator.OR:
                expectBool(node, resType);
                node.type = PrimitiveType.BOOL;
                return node;
            case BinaryOperator.BIT_AND:
            case BinaryOperator.BIT_OR:
            case BinaryOperator.BIT_XOR:
                expectSameSizeBytes(node, node.left.type, node.right.type);
                node.type = node.left.type;
                return node;
            case BinaryOperator.SPLIT:
                expectAnyOfTypes(node, node.left.type, [new BytesType(), PrimitiveType.STRING]);
                expectInt(node, node.right.type);
                // Result of split are two unbounded bytes types (could be improved to do type inference)
                node.type = new TupleType(node.left.type instanceof BytesType ? new BytesType() : PrimitiveType.STRING);
                return node;
            default:
                return node;
        }
    }
    visitUnaryOp(node) {
        node.expression = this.visit(node.expression);
        switch (node.operator) {
            case UnaryOperator.NOT:
                expectBool(node, node.expression.type);
                node.type = PrimitiveType.BOOL;
                return node;
            case UnaryOperator.NEGATE:
                expectInt(node, node.expression.type);
                node.type = PrimitiveType.INT;
                return node;
            case UnaryOperator.SIZE:
                expectAnyOfTypes(node, node.expression.type, [new BytesType(), PrimitiveType.STRING]);
                node.type = PrimitiveType.INT;
                return node;
            case UnaryOperator.REVERSE:
                expectAnyOfTypes(node, node.expression.type, [new BytesType(), PrimitiveType.STRING]);
                // Type is preserved
                node.type = node.expression.type;
                return node;
            case UnaryOperator.INPUT_VALUE:
            case UnaryOperator.INPUT_OUTPOINT_INDEX:
            case UnaryOperator.INPUT_SEQUENCE_NUMBER:
            case UnaryOperator.OUTPUT_VALUE:
            case UnaryOperator.INPUT_TOKEN_AMOUNT:
            case UnaryOperator.OUTPUT_TOKEN_AMOUNT:
                expectInt(node, node.expression.type);
                node.type = PrimitiveType.INT;
                return node;
            case UnaryOperator.INPUT_LOCKING_BYTECODE:
            case UnaryOperator.INPUT_UNLOCKING_BYTECODE:
            case UnaryOperator.OUTPUT_LOCKING_BYTECODE:
            case UnaryOperator.INPUT_NFT_COMMITMENT:
            case UnaryOperator.OUTPUT_NFT_COMMITMENT:
            case UnaryOperator.INPUT_TOKEN_CATEGORY:
            case UnaryOperator.OUTPUT_TOKEN_CATEGORY:
                expectInt(node, node.expression.type);
                node.type = new BytesType();
                return node;
            case UnaryOperator.INPUT_OUTPOINT_HASH:
                expectInt(node, node.expression.type);
                node.type = new BytesType(32);
                return node;
            default:
                return node;
        }
    }
    visitNullaryOp(node) {
        switch (node.operator) {
            case NullaryOperator.INPUT_INDEX:
            case NullaryOperator.INPUT_COUNT:
            case NullaryOperator.OUTPUT_COUNT:
            case NullaryOperator.VERSION:
            case NullaryOperator.LOCKTIME:
                node.type = PrimitiveType.INT;
                return node;
            case NullaryOperator.BYTECODE:
                node.type = new BytesType();
                return node;
            default:
                return node;
        }
    }
    visitArray(node) {
        node.elements = this.visitList(node.elements);
        const elementTypes = node.elements.map((e) => {
            if (!e.type)
                throw new ArrayElementError(node);
            return e.type;
        });
        const elementType = arrayType(elementTypes);
        if (!elementType) {
            throw new ArrayElementError(node);
        }
        node.type = new ArrayType(elementType);
        return node;
    }
    visitIdentifier(node) {
        if (!node.definition)
            return node;
        node.type = node.definition.type;
        return node;
    }
}
function expectAnyOfTypes(node, actual, expectedTypes) {
    if (!expectedTypes || expectedTypes.length === 0)
        return;
    if (expectedTypes.find((expected) => implicitlyCastable(actual, expected))) {
        return;
    }
    throw new UnsupportedTypeError(node, actual, expectedTypes[0]);
}
function expectBool(node, actual) {
    expectAnyOfTypes(node, actual, [PrimitiveType.BOOL]);
}
function expectInt(node, actual) {
    expectAnyOfTypes(node, actual, [PrimitiveType.INT]);
}
function expectSameSizeBytes(node, left, right) {
    if (!(left instanceof BytesType) || !(right instanceof BytesType)) {
        throw new UnsupportedTypeError(node, left, new BytesType());
    }
    if (left.bound !== right.bound) {
        throw new UnequalTypeError(node);
    }
}
function expectTuple(node, actual) {
    if (!(actual instanceof TupleType)) {
        throw new UnsupportedTypeError(node, actual, new TupleType());
    }
}
function expectAssignable(node, actual, expected) {
    if (!implicitlyCastable(actual, expected)) {
        throw new AssignTypeError(node);
    }
}
function expectParameters(node, actual, expected) {
    if (!implicitlyCastableSignature(actual, expected)) {
        throw new InvalidParameterTypeError(node, actual, expected);
    }
}
//# sourceMappingURL=TypeCheckTraversal.js.map