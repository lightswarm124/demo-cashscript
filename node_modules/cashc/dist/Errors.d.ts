import { Type } from '@cashscript/utils';
import { IdentifierNode, FunctionDefinitionNode, VariableDefinitionNode, ParameterNode, Node, FunctionCallNode, BinaryOpNode, UnaryOpNode, TimeOpNode, CastNode, AssignNode, BranchNode, ArrayNode, TupleIndexOpNode, RequireNode, InstantiationNode, StatementNode, ContractNode, ExpressionNode } from './ast/AST.js';
import { Symbol, SymbolType } from './ast/SymbolTable.js';
import { Location, Point } from './ast/Location.js';
export declare class CashScriptError extends Error {
    node: Node;
    constructor(node: Node, message: string);
}
export declare class ParseError extends Error {
    constructor(message: string, location?: Point | Location);
}
export declare class UndefinedReferenceError extends CashScriptError {
    node: IdentifierNode;
    constructor(node: IdentifierNode);
}
export declare class InvalidSymbolTypeError extends CashScriptError {
    node: IdentifierNode;
    expected: SymbolType;
    constructor(node: IdentifierNode, expected: SymbolType);
}
export declare class RedefinitionError extends CashScriptError {
}
export declare class FunctionRedefinitionError extends RedefinitionError {
    node: FunctionDefinitionNode;
    constructor(node: FunctionDefinitionNode);
}
export declare class VariableRedefinitionError extends RedefinitionError {
    node: VariableDefinitionNode | ParameterNode;
    constructor(node: VariableDefinitionNode | ParameterNode);
}
export declare class UnusedVariableError extends CashScriptError {
    symbol: Symbol;
    constructor(symbol: Symbol);
}
export declare class EmptyContractError extends CashScriptError {
    node: ContractNode;
    constructor(node: ContractNode);
}
export declare class EmptyFunctionError extends CashScriptError {
    node: FunctionDefinitionNode;
    constructor(node: FunctionDefinitionNode);
}
export declare class FinalRequireStatementError extends CashScriptError {
    node: StatementNode;
    constructor(node: StatementNode);
}
export declare class TypeError extends CashScriptError {
    actual?: Type | Type[] | undefined;
    expected?: Type | Type[] | undefined;
    constructor(node: Node, actual?: Type | Type[] | undefined, expected?: Type | Type[] | undefined, message?: string);
}
export declare class InvalidParameterTypeError extends TypeError {
    constructor(node: FunctionCallNode | RequireNode | InstantiationNode, actual: Type[], expected: Type[]);
}
export declare class UnequalTypeError extends TypeError {
    constructor(node: BinaryOpNode);
}
export declare class UnsupportedTypeError extends TypeError {
    constructor(node: BinaryOpNode | UnaryOpNode | TimeOpNode | TupleIndexOpNode, actual?: Type, expected?: Type);
}
export declare class CastTypeError extends TypeError {
    constructor(node: CastNode);
}
export declare class CastSizeError extends CashScriptError {
    constructor(node: CastNode);
}
export declare class AssignTypeError extends TypeError {
    constructor(node: AssignNode | VariableDefinitionNode);
}
export declare class TupleAssignmentError extends CashScriptError {
    constructor(node: ExpressionNode);
}
export declare class ConstantConditionError extends CashScriptError {
    constructor(node: BranchNode | RequireNode, res: boolean);
}
export declare class ConstantModificationError extends CashScriptError {
    constructor(node: VariableDefinitionNode);
}
export declare class ArrayElementError extends CashScriptError {
    constructor(node: ArrayNode);
}
export declare class IndexOutOfBoundsError extends CashScriptError {
    constructor(node: TupleIndexOpNode);
}
export declare class VersionError extends Error {
    constructor(actual: string, constraint: string);
}
